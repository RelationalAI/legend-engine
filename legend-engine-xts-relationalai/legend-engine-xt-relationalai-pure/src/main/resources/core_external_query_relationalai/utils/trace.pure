import meta::rel::trace::*;

/**
  * A traced computation.
  */
Class meta::rel::trace::Trace { 
  <<equality.Key>> stages: Stage[*];
}

Class meta::rel::trace::Stage {
  <<equality.Key>> stageName: String[1];
  messages: String[*];
}

function meta::rel::trace::emptyTrace(): Trace[1] {
  ^Trace(stages=[])
}

/**
  * Append a named staged to the traced computation. 
  */
function meta::rel::utils::stage(trace: Trace[1], stageName: String[1]): Trace[1] {
  ^$trace(stages=$trace.stages->add(0, ^Stage(stageName=$stageName)))
}

/**
  * Append a message to the current stage.
  */
function meta::rel::utils::detail(trace: Trace[1], label: String[1], message: String[0..1]): Trace[1] {
  let headStage = $trace.stages->at(0);
  let headStageMessages = $headStage.messages;
  let headMessage =
    if ( $message->isEmpty(),
       | $label + ': (none)',
       | $label + ': ' + $message->toOne()
       );
  ^$trace(stages=$trace.stages->tail()->add(0, ^$headStage(messages=$headStageMessages->add($headMessage))));
}


function meta::rel::utils::traceLog(trace: Trace[0..1]): String[*] {
  if($trace->isEmpty(),
    | ['(no trace)'],
    | if($trace.stages->isEmpty(),
        | ['(empty trace)'],
        {|
          $trace.stages
            ->reverse()
            ->toNumbered()
            ->map(p: Pair<Integer,Stage>[1] |
              let stage = $p.second;
              let messages = $stage.messages;
              let line = format('stage %s: %s', [$p.first, $stage.stageName]);
              if ( $messages->isEmpty(),
                | $line,
                | $line + $messages->makeString('\n    ', '\n    ', '');
                );
            )
            ->reverse()
        }
      )
  )
}
