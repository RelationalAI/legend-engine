import meta::pure::router::metamodel::*;
import meta::pure::router::store::metamodel::*;
import meta::rel::compile::ir::*;
import meta::rel::mapping::*;
import meta::rel::trace::*;
import meta::rel::utils::*;

//////////////////////////////////////////
// Handling creation of variable scopes //
//////////////////////////////////////////

function meta::rel::compile::ir::valueSpecToScoped(
  spec: ValueSpecification[1],
  trace: Trace[1]
): Result<PExprScope|0..1>[1] {
  let newTrace = $trace->stage('valueSpecToScoped(ValueSpecification[1],Trace[1])');
  $spec->valueSpecToScoped([], $newTrace);
}

function meta::rel::compile::ir::valueSpecToScoped(
  spec: ValueSpecification[1],
  parent: PExpr[0..1],
  trace: Trace[1]
): Result<PExprScope|0..1>[1] {
  let newTrace = $trace->stage('valueSpecToScoped(ValueSpecification[1],PExpr[0..1],Trace[1])');
  $spec->match([
    {spec: InstanceValue[1] |
        $spec.values
          ->first()
          ->okOr(| errorTrace('Expected one value in `InstanceValue`.', $newTrace))
          ->tryCast(@FunctionRoutedValueSpecification, $newTrace)
          ->andThen(func: FunctionRoutedValueSpecification[1] |
            $func->valueSpecToScoped($parent, $newTrace)
          )
    },
    {spec: FunctionRoutedValueSpecification[1] |
      $spec.value
        ->tryCast(@InstanceValue, $newTrace)
        ->andThen(value: InstanceValue[1] |
          $value.values
            ->first()
            ->okOr(| errorTrace('Expected one value in `InstanceValue`.', $newTrace))
            ->tryCast(@FunctionDefinition<Any>, $newTrace)
            ->andThen(func: FunctionDefinition<Any>[1] |
              $func->functionDefToScoped($parent, $newTrace)
            )
        )
    },
    {spec: RoutedValueSpecification[1] |
      $spec.value
        ->tryCast(@FunctionRoutedValueSpecification, $newTrace)
        ->andThen(inner: FunctionRoutedValueSpecification[1] |
          $inner->valueSpecToScoped($parent, $newTrace)
        )
    }
  ]);
}

function meta::rel::compile::ir::functionDefToScoped(
  func: FunctionDefinition<Any>[1],
  parent: PExpr[0..1],
  trace: Trace[1]
): Result<PExprScope|0..1>[1] {
  let newTrace = $trace->stage('functionDefToScoped(FunctionDefinition<Any>[1],PExpr[0..1],Trace[1])');
  let functionParams = $func->functionType().parameters;

  $func.expressionSequence
    ->evaluateAndDeactivate()
    ->okOr(| errorTrace('Encountered empty function body while evaluating expression.', $newTrace))
    ->andThem(exprs: ValueSpecification[*] |
      if ($exprs->size() != 1,
        | error('More than one expression in function body not supported yet.', $newTrace),
        | $exprs->toOne()->ok()
      )
    )
    ->andThen(spec: ValueSpecification[1] |
      /*
       * If `spec` is a StoreMappingRoutedValueSpecification, then annotate the
       * variable scope introduced with the type given by the RelSetImplementation
       * of the value specification. Otherwise, introduce the variable scope
       * without type annotation.
       *
       * FIXME: In the typed case we only have one variable, whereas in the typed
       * case we can have more than one variable (e.g., in the case of joins).
       */
      $spec
        ->tryCast(@StoreMappingRoutedValueSpecification, $newTrace)
        ->andThen(spec: StoreMappingRoutedValueSpecification[1] |
          $spec->storeMappingRoutedValueSpecToRelSet($newTrace)
        )
        ->orDefaultValue([])
        ->andThen(set: RelSetImplementation[0..1] |
          $spec
            ->valueSpecToPExpr($newTrace)
            ->andThen(inner: PExpr[1] |
              $functionParams
                ->evaluateAndDeactivate()
                ->tryCastm(@VariableExpression, $newTrace)
                ->andThem(vars: VariableExpression[*] |
                  if (!$set->isEmpty(), {|
                    if ($vars->size() != 1,
                      | error('Cannot type multiple variable with single set implementation.', $newTrace),
                      | $inner->scopeTyped($vars->toOne().name, $set->toOne(), $parent)->ok()
                      )
                  }, {|
                    $inner->scopeUntyped($vars.name, $parent)->ok()
                  })
                );
            )

        );

    );
}


function meta::rel::compile::ir::valueSpecToTypedScopes(
  spec: ValueSpecification[1],
  trace: Trace[1]
): Result<PExprScopeTyped|0..1>[*] {
  let newTrace = $trace->stage('valueSpecToTypedScopes(ValueSpecification[1],Trace[1])');
  $spec->valueSpecToTypedScopes([], $newTrace);
}

function meta::rel::compile::ir::valueSpecToTypedScopes(
  spec: ValueSpecification[1],
  parent: PExpr[0..1],
  trace: Trace[1]
): Result<PExprScopeTyped|0..1>[*] {
  /*
   * To try to avoid repetition, instead of unpacking the value specification in a
   * similar way in order to obtain a typed variable, we instead attempt to cast at
   * the end. We prefer to construct typed variables where possible, and this cast
   * will succeed if a typed variable has been constructed.
   */
  let newTrace = $trace->stage('valueSpecToTypedScopes(ValueSpecification[1],PExpr[1],Trace[1])');
  $spec
    ->valueSpecToScopes($parent, $newTrace)
    ->map(result: Result<PExprScope|0..1>[1] |
      $result->tryCast(@PExprScopeTyped, $newTrace);
    );
}

function meta::rel::compile::ir::valueSpecToScopes(
  spec: ValueSpecification[1],
  trace: Trace[1]
): Result<PExprScope|0..1>[*] {
  let newTrace = $trace->stage('valueSpecToScopes(ValueSpecification[1],Trace[1])');
  $spec->valueSpecToScopes([], $newTrace);
}

function meta::rel::compile::ir::valueSpecToScopes(
  spec: ValueSpecification[1],
  parent: PExpr[0..1],
  trace: Trace[1]
): Result<PExprScope|0..1>[*] {
  let newTrace = $trace->stage('valueSpecToScopes(ValueSpecification[1],PExpr[1],Trace[1])');
  $spec->match([
    spec: InstanceValue[1] | 
      $spec.values
        ->map(v | 
          $v->map(f: ValueSpecification[1] | $f->valueSpecToScoped($parent, $newTrace))
        ),
    spec: ExtendedRoutedValueSpecification[1] | $spec.value->valueSpecToScopes($parent, $newTrace),
    other: ValueSpecification[1] | $other->valueSpecToScoped($parent, $newTrace)
  ]);
}
