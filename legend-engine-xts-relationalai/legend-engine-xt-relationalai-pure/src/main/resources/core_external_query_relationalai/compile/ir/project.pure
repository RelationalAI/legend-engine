import meta::rel::compile::ir::*;
import meta::rel::mapping::*;
import meta::rel::utils::*;
import meta::rel::utils::lang::*;
import meta::pure::router::metamodel::*;

function <<access.private>> meta::rel::compile::ir::handleCaseProject1(func: FunctionExpression[1]): Result<PExpr|0..1>[1] {
  assert($func.func == project_T_MANY__Path_MANY__TabularDataSet_1_);

  let param0 = $func.parametersValues->at(0);
  // Second argument is the path.
  let param1 = $func.parametersValues->at(1);

  $param0
    ->intoPExpr()
    ->andThen({parent: PExpr[1] |
      switch([
        case($param1->instanceOf(ExtendedRoutedValueSpecification), 
          | $param1
              ->cast(@ExtendedRoutedValueSpecification)
              .value
              ->cast(@InstanceValue)
              .values
              ->cast(@meta::pure::metamodel::path::Path<Nil,Any|1>)
        ),
        case($param1->instanceOf(InstanceValue), | 
          $param1
            ->cast(@InstanceValue)
            .values
            ->cast(@meta::pure::metamodel::path::Path<Nil,Any|1>)
        )
      ], {| $param1->reactivate(); })
      ->okOr(| 'Encountered unknown argument during compilation of `project_T_MANY__Path_MANY__TabularDataSet_1_`.')
      ->andThem({paths: meta::pure::metamodel::path::Path<Nil,Any|1>[*] |
        $parent
          ->set()
          ->okOr(| 'Expected set in parent expression of `project_T_MANY__Path_MANY__TabularDataSet_1_`.')
          ->andThen({set: RelSetImplementation[1] |
            $paths
              ->map({path |
                $path.path
                  ->fold({element, accum |
                    $accum
                      ->andThen({expr: PExpr[1] |
                        $element
                          ->tryCast(@meta::pure::metamodel::path::PropertyPathElement)
                          ->andThen(p: meta::pure::metamodel::path::PropertyPathElement[1] | $p.property->tryCast(@Property<Nil,Any|*>))
                          ->andThen({property: Property<Nil,Any|*>[1] | 
                            $property
                              .genericType
                              .rawType
                              ->okOr(| format('No type information for property `%s`.', $property.name))
                              ->then({type: Type[1] |
                                let next = 
                                  $set
                                    .parent
                                    ->meta::pure::mapping::classMappingById($type->elementToPath('_'))
                                    ->map(set | $set->cast(@RelSetImplementation));
                                
                                $expr->propertyAccess($property, $next);
                              })
                          });
                      });
                  }, ok(setAccess($set, 'x')))
                  ->then(expr: PExpr[1] | 
                    let name = 
                      if ($path.name->isEmpty() || $path.name == '', {| 
                        $path.path
                          ->last()
                          ->map({last | 
                            if ($last->instanceOf(meta::pure::metamodel::path::PropertyPathElement), {|
                              $last
                                ->cast(@meta::pure::metamodel::path::PropertyPathElement)
                                .property
                                .name
                                ->orElse('')
                            }, | '')
                          })
                          ->orElse('');
                      }, | $path.name)
                      ->orElse('');

                    pair($name, $expr->scoped('x')->withParent($parent));
                  );
              })
              ->collect()
              ->them({pairs: Pair<String, Scoped>[*] |
                $parent->project($pairs);
              });
          });
      });
    });
}

function <<access.private>> meta::rel::compile::ir::handleCaseProject2(func: FunctionExpression[1]): Result<PExpr|0..1>[1] {
  assert($func.func == project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_ ||
         $func.func == project_TabularDataSet_1__ColumnSpecification_MANY__TabularDataSet_1_);

  let param0 = $func.parametersValues->at(0);
  // Second argument is the column specification.
  let param1 = $func.parametersValues->at(1);

  $param0
    ->intoPExpr()
    ->andThen({parent: PExpr[1] |
      $param1
        ->tryCast(@InstanceValue)
        ->andThen({params: InstanceValue[1] |
          $params.values
            ->map({v | 
              $v->tryCast(@InstanceValue)
                ->then(i: InstanceValue[1] | 
                  // Values guaranteed by function signature
                  $i.values
                    ->toOne()
                    ->cast(@BasicColumnSpecification<Any>)
                );
            })
            ->collect()
            ->andThem({columns: BasicColumnSpecification<Any>[*] |
              $columns.func
                ->map(f | 
                  $f->tryCast(@FunctionDefinition<Any>)
                    ->andThen(fexpr: FunctionDefinition<Any>[1] | $fexpr->intoScoped($parent))
                )
                ->collect()
                ->them(fexprs | $parent->project($columns.name->zip($fexprs)));
            });
        });
    });
}

function <<access.private>> meta::rel::compile::ir::handleCaseProject3(func: FunctionExpression[1]): Result<PExpr|0..1>[1] {
  assert($func.func == project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_);

  let param0 = $func.parametersValues->at(0);
  // Second argument is the function (what is this??).
  let param1 = $func.parametersValues->at(1);
  // Third argument is the column names.
  let param2 = $func.parametersValues->at(2);

  $param0
    ->intoPExpr()
    ->andThen({parent: PExpr[1] |

  $param1
    ->tryCast(@InstanceValue)
    ->andThen({params: InstanceValue[1] |
      $params.values
        ->map( v |
          $v->tryCast(@FunctionRoutedValueSpecification)
            ->then(s: FunctionRoutedValueSpecification[1] |
              // CHECK: Is value type guarenteed?
              $s.value->cast(@InstanceValue)
            )
        )
        ->collect()
        ->andThem(i: InstanceValue[*] |
          $i.values
            ->map(v |
              // Type Result<Project>
              $v->tryCast(@FunctionDefinition<Any>)
                ->andThen(fexpr: FunctionDefinition<Any>[1] | $fexpr->intoScoped($parent))
            )
            ->collect()
            ->andThem(fexprs: Scoped[*] |
              // Type Result<Project>
              $param2->tryCast(@InstanceValue)->then(param: InstanceValue[1] |
                // Type guareteed by function signature.
                let columnNames = $param.values->cast(@String);
                $parent->project($columnNames->zip($fexprs));
              )
            )
        )
    })
  });
}