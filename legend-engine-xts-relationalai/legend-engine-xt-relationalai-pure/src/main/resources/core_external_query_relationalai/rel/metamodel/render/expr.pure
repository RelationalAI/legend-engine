import meta::pure::functions::collection::*;
import meta::rel::metamodel::*;
import meta::rel::metamodel::render::binding::*;
import meta::rel::metamodel::render::expr::*;
import meta::rel::utils::*;


Class meta::rel::metamodel::render::expr::RenderState {
  depth: Integer[1];
}

function meta::rel::metamodel::render::expr::freshRenderState(): RenderState[1] {
  ^RenderState(depth=1)
}

function meta::rel::metamodel::render::expr::indent(state: RenderState[1]): RenderState[1] {
  ^$state(depth=$state.depth+1)
}

////////////////////////////////////////
// Rendering non-constant expressions //
////////////////////////////////////////

function meta::rel::metamodel::render::expr::render(tuple: Tuple[1], state: RenderState[1]): String[1] {
  format('(%s)', $tuple.arguments->render($state))
}

function meta::rel::metamodel::render::expr::render(tuples: Tuple[*], state: RenderState[1]): String[1] {
  $tuples->stringify(t | $t->render($state), '; ')
}

function meta::rel::metamodel::render::expr::render(cons: RelationCons[1], state: RenderState[1]): String[1] {
  if ($cons.arguments->isEmpty(),
    | 'false',
    | if ($cons.arguments->size() == 1 && $cons.arguments->at(0).arguments->isEmpty(),
        | 'true',
        | format('{%s}', $cons.arguments->render($state)
        )
    )
  )
}

function meta::rel::metamodel::render::expr::render(rel: RelationName[1], state: RenderState[1]): String[1] {
  $rel.identifier
}

function meta::rel::metamodel::render::expr::render(expr: HeadExpr[1], state: RenderState[1]): String[1] {
  $expr->match([
    rel: RelationName[1]     | $rel->render($state),
    app: NamedApplication[1] | $app->render($state)
  ])
}

function meta::rel::metamodel::render::expr::render(app: NamedApplication[1], state: RenderState[1]): String[1] {
  $app->match([
    atom: NamedAtom[1]     | $atom->render($state),
    a: NamedApplication[1] |
      let renderedArguments =
        if (!$a.arguments->isEmpty(),
          | format('[%s]', $a.arguments->render($state)),
          | ''
          );
      $a.head->render($state) + $renderedArguments;
  ])
}

function meta::rel::metamodel::render::expr::render(atom: NamedAtom[1], state: RenderState[1]): String[1] {
  let renderedArguments =
    if (!$atom.arguments->isEmpty(),
      | format('(%s)', $atom.arguments->render($state)),
      | ''
      );
  $atom.head->render($state) + $renderedArguments;
}

function meta::rel::metamodel::render::expr::render(atom: Atom[1], state: RenderState[1]): String[1] {
  let renderedArguments =
    if (!$atom.arguments->isEmpty(),
      | format('(%s)', $atom.arguments->render($state)),
      | ''
      );
  $atom.head->render($state) + $renderedArguments;
}

function meta::rel::metamodel::render::expr::render(and: And[1], state: RenderState[1]): String[1] {
  $and.conjuncts->render(' and ', $state)
}

function meta::rel::metamodel::render::expr::render(or: Or[1], state: RenderState[1]): String[1] {
  $or.disjuncts->render(' or ', $state)
}

function meta::rel::metamodel::render::expr::render(not: Not[1], state: RenderState[1]): String[1] {
  format('not %s', $not.inner->render($state))
}

function meta::rel::metamodel::render::expr::render(implies: Implies[1], state: RenderState[1]): String[1] {
  format('%s implies %s', [$implies.antecedence->render($state), $implies.consequence->render($state)])
}

function meta::rel::metamodel::render::expr::render(exists: Exists[1], state: RenderState[1]): String[1] {
  format('exists%s', $exists.inner->render($state))
}

function meta::rel::metamodel::render::expr::render(forAll: ForAll[1], state: RenderState[1]): String[1] {
  format('forall(%s: %s)', [$forAll.bindings->renderBinding($state), $forAll.inner->render($state)])
}

function meta::rel::metamodel::render::expr::render(equals: Equals[1], state: RenderState[1]): String[1] {
  format('%s = %s', [$equals.left->render($state), $equals.right->render($state)])
}

function meta::rel::metamodel::render::expr::render(app: Application[1], state: RenderState[1]): String[1] {
  $app->match([
    a: Atom[1] | $a->render($state),
    a: Application[1] |
      let renderedArguments =
        if (!$app.arguments->isEmpty(),
          | format('[%s]', $app.arguments->render($state)),
          | ''
          );
      $app.head
        ->render($state)
        ->maybeParentheses(!$app.head->canUnambigouslyApply()) + $renderedArguments;
  ])
}

function meta::rel::metamodel::render::expr::render(abstraction: Abstraction[1], state: RenderState[1]): String[1] {
  format('(%s: %s)', [$abstraction.bindings->renderBinding($state), $abstraction.body->render($state)])
}

function meta::rel::metamodel::render::expr::render(composition: Composition[1], state: RenderState[1]): String[1] {
  format('%s.%s', [$composition.from->render($state), $composition.to->render($state)])
}

function meta::rel::metamodel::render::expr::render(from: From[1], state: RenderState[1]): String[1] {
  format('%s from %s', [$from.expr->render($state), $from.bindings->renderBinding($state)])
}

function meta::rel::metamodel::render::expr::render(for: For[1], state: RenderState[1]): String[1] {
  format('%s for %s', [$for.expr->render($state), $for.bindings->renderBinding($state)])
}

function meta::rel::metamodel::render::expr::render(exprs: Expr[*], separator: String[1], state: RenderState[1]): String[1] {
  $exprs->stringify(e: Expr[1] | $e->render($state), $separator)
}

function meta::rel::metamodel::render::expr::render(exprs: Expr[*], state: RenderState[1]): String[1] {
  $exprs->render(', ', $state)
}

function meta::rel::metamodel::render::expr::render(product: Product[1], state: RenderState[1]): String[1] {
  format('%s', $product.exprs->render($state))
}

function meta::rel::metamodel::render::expr::render(group: ExprGroup[1], state: RenderState[1]): String[1] {
  format('(%s)', $group.parent->render($state))
}

function meta::rel::metamodel::render::expr::render(union: Union[1], state: RenderState[1]): String[1] {
  format('%s', $union.exprs->stringify(e: Expr[1] | $e->render($state), '; '))
}

function meta::rel::metamodel::render::expr::render(ifThenElse: IfThenElse[1], state: RenderState[1]): String[1] {
  format('if %s then %s else %s end', [
    $ifThenElse.condition->render($state),
    $ifThenElse.then->render($state),
    $ifThenElse.else->render($state)
  ]);
}

function meta::rel::metamodel::render::expr::render(expr: Expr[1], state: RenderState[1]): String[1] {
  $expr->match([
    e: Fragment[1]         | $e.code,
    e: Abstraction[1]      | $e->render($state),
    e: And[1]              | $e->render($state),
    e: Application[1]      | $e->render($state),
    e: Atom[1]             | $e->render($state),
    e: Composition[1]      | $e->render($state),
    e: Constant[1]         | $e->render($state),
    e: DontCare[1]         | $e->render($state),
    e: Equals[1]           | $e->render($state),
    e: Exists[1]           | $e->render($state),
    e: ExprGroup[1]        | $e->render($state),
    e: For[1]              | $e->render($state),
    e: ForAll[1]           | $e->render($state),
    e: From[1]             | $e->render($state),
    e: HeadExpr[1]         | $e->render($state),
    e: IfThenElse[1]       | $e->render($state),
    e: Implies[1]          | $e->render($state),
    e: NamedApplication[1] | $e->render($state),
    e: NamedAtom[1]        | $e->render($state),
    e: Not[1]              | $e->render($state),
    e: Or[1]               | $e->render($state),
    e: Product[1]          | $e->render($state),
    e: RelationCons[1]     | $e->render($state),
    e: Tuple[1]            | $e->render($state),
    e: Union[1]            | $e->render($state),
    e: Variable[1]         | $e->renderBinding($state),
    e: Variables[1]        | $e->renderBinding($state)
  ]);
}

//////////////////////////////////////////////////////
// Rendering entry point when not providing a state //
//////////////////////////////////////////////////////

function meta::rel::metamodel::render::expr::renderExpr(expr: Expr[1]): String[1] {
  render($expr, freshRenderState())
}

function meta::rel::metamodel::render::expr::renderExprs(exprs: Expr[*]): String[1] {
  $exprs->render(', ', freshRenderState())
}

///////////////////////
// Utility functions //
///////////////////////

function <<access.private>> meta::rel::metamodel::render::expr::maybeParentheses(str: String[1], do: Boolean[1]): String[1] {
  if ($do, | format('(%s)', $str), | $str)
}

function <<access.private>> meta::rel::metamodel::render::expr::canUnambigouslyApply(expr: Expr[1]): Boolean[1] {
  $expr->match([
    e: Abstraction[1]      | true,
    e: Application[1]      | true,
    e: Composition[1]      | true,
    e: Constant[1]         | true,
    e: DontCare[1]         | true,
    e: ExprGroup[1]        | true,
    e: HeadExpr[1]         | true,
    e: NamedApplication[1] | true,
    e: Product[1]          | true,
    e: RelationCons[1]     | true,
    e: Tuple[1]            | true,
    e: Union[1]            | true,
    e: Variable[1]         | true,
    e: Variables[1]        | true,
    e: For[1]              | false,
    e: From[1]             | false,
    e: Not[1]              | false
  ])
}
