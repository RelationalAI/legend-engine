import meta::pure::functions::collection::*;
import meta::rel::metamodel::*;
import meta::rel::metamodel::render::*;
import meta::rel::utils::*;


function meta::rel::metamodel::render::render(constant: RelString[1]): String[1] {
  format('"%s"', $constant.value)
}

function meta::rel::metamodel::render::render(constant: RelInteger[1]): String[1] {
  $constant.value->toString()
}

function meta::rel::metamodel::render::render(constant: RelFloat[1]): String[1] {
  $constant.value->toString()
}

function meta::rel::metamodel::render::render(constant: RelDate[1]): String[1] {
  $constant.value->toString()
}

function meta::rel::metamodel::render::render(constant: RelDateTime[1]): String[1] {
  format(
    '%d-%02d-%02dT%02d:%02d:%02dZ',
    [
      $constant.value->year(),
      $constant.value->monthNumber(),
      $constant.value->dayOfMonth()->toOne(),
      $constant.value->hour(),
      $constant.value->minute(),
      $constant.value->second()
    ]
  )
}

function meta::rel::metamodel::render::render(dontCare: DontCare[1]): String[1] {
  '_'
}

function meta::rel::metamodel::render::render(constant: Constant[1]): String[1] {
  $constant->match([
    c: RelString[1]   | $c->render(),
    c: RelInteger[1]  | $c->render(),
    c: RelFloat[1]    | $c->render(),
    c: RelDate[1]     | $c->render(),
    c: RelDateTime[1] | $c->render(),
    c: Label[1] |
      if ($c.identifier->isAlphaNumeric() && ($c.identifier->size() > 0) && !$c.identifier->substring(0, 1)->isDigit(),
        | format(':%s', $c.identifier),
        | format(':"%s"', $c.identifier)
      )
  ])
}

function meta::rel::metamodel::render::render(constants: Constant[*]): String[1] {
  $constants->stringify(c | $c->render(), ', ')
}

function meta::rel::metamodel::render::render(tuple: Tuple[1]): String[1] {
  format('(%s)', $tuple.arguments->render())
}

function meta::rel::metamodel::render::render(tuples: Tuple[*]): String[1] {
  $tuples->stringify(t | $t->render(), '; ')
}

function meta::rel::metamodel::render::render(cons: RelationCons[1]): String[1] {
  if ($cons.arguments->isEmpty(),
    | 'false',
    | if ($cons.arguments->size() == 1 && $cons.arguments->at(0).arguments->isEmpty(),
        | 'true',
        | format('{%s}', $cons.arguments->render()
        )
    )
  )
}

function meta::rel::metamodel::render::render(rel: RelationName[1]): String[1] {
  $rel.identifier
}

function meta::rel::metamodel::render::render(var: Variable[1]): String[1] {
  $var.identifier
}

function meta::rel::metamodel::render::render(vars: Variable[*]): String[1] {
  $vars->stringify(v | $v->render(), ', ')
}

function meta::rel::metamodel::render::render(vars: Variables[1]): String[1] {
  $vars.inner->render()
}

function meta::rel::metamodel::render::render(binding: InBinding[1]): String[1] {
  format('%s in %s', [$binding.variable->render(), $binding.in->render()])
}

function meta::rel::metamodel::render::render(binding: WhereBinding[1]): String[1] {
  format('%s where %s', [$binding.parents->render(), $binding.where->render()])
}

function meta::rel::metamodel::render::render(binding: Binding[1]): String[1] {
  $binding->match([
    b: InBinding[1]    | $b->render(),
    v: Variable[1]     | $v->render(),
    vs: Variables[1]   | $vs->render(),
    b: WhereBinding[1] | $b->render()
  ])
}

function meta::rel::metamodel::render::render(bindings: Binding[*]): String[1] {
  $bindings->stringify(b | $b->render(), ', ');
}

function meta::rel::metamodel::render::render(expr: HeadExpr[1]): String[1] {
  $expr->match([
    rel: RelationName[1]     | $rel->render(),
    app: NamedApplication[1] | $app->render()
  ])
}

function meta::rel::metamodel::render::render(app: NamedApplication[1]): String[1] {
  $app->match([
    atom: NamedAtom[1]     | $atom->render(),
    a: NamedApplication[1] |
      let renderedArguments =
        if (!$a.arguments->isEmpty(),
          | format('[%s]', $a.arguments->render()),
          | ''
          );
      $a.head->render() + $renderedArguments;
  ])
}

function meta::rel::metamodel::render::render(atom: NamedAtom[1]): String[1] {
  let renderedArguments =
    if (!$atom.arguments->isEmpty(),
      | format('(%s)', $atom.arguments->render()),
      | ''
      );
  $atom.head->render() + $renderedArguments;
}

function meta::rel::metamodel::render::render(atom: Atom[1]): String[1] {
  let renderedArguments =
    if (!$atom.arguments->isEmpty(),
      | format('(%s)', $atom.arguments->render()),
      | ''
      );
  $atom.head->render() + $renderedArguments;
}

function meta::rel::metamodel::render::render(and: And[1]): String[1] {
  $and.conjuncts->render(' and ')
}

function meta::rel::metamodel::render::render(or: Or[1]): String[1] {
  $or.disjuncts->render(' or ')
}

function meta::rel::metamodel::render::render(not: Not[1]): String[1] {
  format('not %s', $not.inner->render())
}

function meta::rel::metamodel::render::render(implies: Implies[1]): String[1] {
  format('%s implies %s', [$implies.antecedence->render(), $implies.consequence->render()])
}

function meta::rel::metamodel::render::render(exists: Exists[1]): String[1] {
  format('exists%s', $exists.inner->render())
}

function meta::rel::metamodel::render::render(forAll: ForAll[1]): String[1] {
  format('forall(%s: %s)', [$forAll.bindings->render(), $forAll.inner->render()])
}

function meta::rel::metamodel::render::render(equals: Equals[1]): String[1] {
  format('%s = %s', [$equals.left->render(), $equals.right->render()])
}

function meta::rel::metamodel::render::render(app: Application[1]): String[1] {
  $app->match([
    a: Atom[1] | $a->render(),
    a: Application[1] |
      let renderedArguments =
        if (!$app.arguments->isEmpty(),
          | format('[%s]', $app.arguments->render()),
          | ''
          );
      $app.head
        ->render()
        ->maybeParentheses(!$app.head->canUnambigouslyApply()) + $renderedArguments;
  ])
}

function meta::rel::metamodel::render::render(abstraction: Abstraction[1]): String[1] {
  format('(%s: %s)', [$abstraction.bindings->render(), $abstraction.body->render()])
}

function meta::rel::metamodel::render::render(composition: Composition[1]): String[1] {
  format('%s.%s', [$composition.from->render(), $composition.to->render()])
}

function meta::rel::metamodel::render::render(from: From[1]): String[1] {
  format('%s from %s', [$from.expr->render(), $from.bindings->render()])
}

function meta::rel::metamodel::render::render(for: For[1]): String[1] {
  format('%s for %s', [$for.expr->render(), $for.bindings->render()])
}

function meta::rel::metamodel::render::render(exprs: Expr[*], separator: String[1]): String[1] {
  $exprs->stringify(e | $e->render(), $separator)
}

function meta::rel::metamodel::render::render(exprs: Expr[*]): String[1] {
  $exprs->render(', ')
}

function meta::rel::metamodel::render::render(product: Product[1]): String[1] {
  format('%s', $product.exprs->render())
}

function meta::rel::metamodel::render::render(group: ExprGroup[1]): String[1] {
  format('(%s)', $group.parent->render())
}

function meta::rel::metamodel::render::render(union: Union[1]): String[1] {
  format('%s', $union.exprs->stringify(e | $e->render(), '; '))
}

function meta::rel::metamodel::render::render(ifThenElse: IfThenElse[1]): String[1] {
  format('if %s then %s else %s end', [
    $ifThenElse.condition->render(),
    $ifThenElse.then->render(),
    $ifThenElse.else->render()
  ]);
}

function meta::rel::metamodel::render::render(expr: Expr[1]): String[1] {
  $expr->match([
    e: Fragment[1]         | $e.code,
    e: Abstraction[1]      | $e->render(),
    e: And[1]              | $e->render(),
    e: Application[1]      | $e->render(),
    e: Atom[1]             | $e->render(),
    e: Composition[1]      | $e->render(),
    e: Constant[1]         | $e->render(),
    e: DontCare[1]         | $e->render(),
    e: Equals[1]           | $e->render(),
    e: Exists[1]           | $e->render(),
    e: ExprGroup[1]        | $e->render(),
    e: For[1]              | $e->render(),
    e: ForAll[1]           | $e->render(),
    e: From[1]             | $e->render(),
    e: HeadExpr[1]         | $e->render(),
    e: IfThenElse[1]       | $e->render(),
    e: Implies[1]          | $e->render(),
    e: NamedApplication[1] | $e->render(),
    e: NamedAtom[1]        | $e->render(),
    e: Not[1]              | $e->render(),
    e: Or[1]               | $e->render(),
    e: Product[1]          | $e->render(),
    e: RelationCons[1]     | $e->render(),
    e: Tuple[1]            | $e->render(),
    e: Union[1]            | $e->render(),
    e: Variable[1]         | $e->render(),
    e: Variables[1]        | $e->render()
  ]);
}

function meta::rel::metamodel::render::render(entityDef: EntityDef[1]): String[1] {
  let annotation = if ($entityDef.inline, | '@inline\n', | '');
  $annotation + format('entity %s %s = %s', [$entityDef.name->render(), $entityDef.head->render(), $entityDef.body->render()]);
}

function meta::rel::metamodel::render::render(rule: Rule[1]): String[1] {
  $rule->match([
    r: EntityDef[1] | $r->render(),
    r: IC[1]        | $r->render(),
    r: Rule[1]      |
      let annotation = if ($r.inline, | '@inline\n', | '');
      $annotation + format('def %s = %s', [$r.head->render(), $r.body->render()]);
  ])
}

function meta::rel::metamodel::render::render(ic: IC[1]): String[1] {
  format('ic %s {\n%s\n}', [$ic.head->render(), $ic.body->render()])
}

function meta::rel::metamodel::render::render(comment: Comment[1]): String[1] {
  $comment->match([
    lc: LineComment[1] | $lc->render()
  ])
}

function meta::rel::metamodel::render::render(comment: LineComment[1]): String[1] {
  format('// %s', $comment.text)
}

function meta::rel::metamodel::render::render(element: ProgramElement[1]): String[1] {
  $element->match([
    r: Rule[1] | $r->render(),
    r: RawRule[1] | $r.code,
    c: Comment[1] | $c->render()
  ])
}

function meta::rel::metamodel::render::render(elements: ProgramElement[*]): String[1] {
  $elements->fold({e: ProgramElement[1], accum: String[1] | $accum + $e->render() + '\n'}, '')
}

function meta::rel::metamodel::render::render(program: Program[1]): String[1] {
  $program.elements->render()
}

function <<access.private>> meta::rel::metamodel::render::maybeParentheses(str: String[1], do: Boolean[1]): String[1] {
  if ($do, | format('(%s)', $str), | $str)
}

function <<access.private>> meta::rel::metamodel::render::canUnambigouslyApply(expr: Expr[1]): Boolean[1] {
  $expr->match([
    e: Abstraction[1]      | true,
    e: Application[1]      | true,
    e: Composition[1]      | true,
    e: Constant[1]         | true,
    e: DontCare[1]         | true,
    e: ExprGroup[1]        | true,
    e: HeadExpr[1]         | true,
    e: NamedApplication[1] | true,
    e: Product[1]          | true,
    e: RelationCons[1]     | true,
    e: Tuple[1]            | true,
    e: Union[1]            | true,
    e: Variable[1]         | true,
    e: Variables[1]        | true,
    e: For[1]              | false,
    e: From[1]             | false,
    e: Not[1]              | false
  ])
}