import meta::pure::executionPlan::*;
import meta::rel::utils::*;
import meta::rel::utils::lang::*;
import meta::rel::utils::collection::*;
import meta::rel::metamodel::store::*;
import meta::rel::mapping::*;
import meta::rel::compile::ir::*;
import meta::rel::compile::*;
import meta::rel::compile::utils::*;
import meta::rel::metamodel::render::*;
import meta::rel::metamodel::*;
import meta::rel::execute::*;
import meta::rel::mapping::*;
import meta::rel::contract::*;


Class meta::rel::mapping::KeyInformation extends meta::pure::mapping::MappingInstanceData {
   pk: Any[*];
   sourceConnection: meta::pure::runtime::Connection[1];
}

Class meta::rel::mapping::QueryActivity extends meta::pure::mapping::Activity {
  relSource: String[1];
  executionTimeInMS: Number[1];
}

function meta::rel::mapping::execution(
  sq: meta::pure::mapping::StoreQuery[1], 
  _ext: RoutedValueSpecification[0..1], 
  mapping: meta::pure::mapping::Mapping[1], 
  runtime: meta::pure::runtime::Runtime[1], 
  exeCtx: meta::pure::runtime::ExecutionContext[1], 
  extensions: meta::pure::extension::Extension[*], 
  debug: DebugContext[1]
): meta::pure::mapping::Result<Any|*>[1] {
  if (!$sq.store->instanceOf(RAIDatabase), | fail('Rel queries can only be executed against an instance of `RAIDatabase`'), | '');

  $sq.fe->execution(
    $sq.store->cast(@RAIDatabase),
    $mapping,
    $runtime,
    $sq.inScopeVars,
    $exeCtx,
    $extensions,
    $debug
  );
}

function <<access.private>> meta::rel::mapping::execution(
  query: FunctionExpression[1],
  store: RAIDatabase[1],
  mapping: meta::pure::mapping::Mapping[1],
  runtime: meta::pure::runtime::Runtime[1], 
  inScopeVars: Map<String, List<Any>>[1],
  exeCtx: meta::pure::runtime::ExecutionContext[1], 
  extensions: meta::pure::extension::Extension[*], 
  debug: DebugContext[1]
): meta::pure::mapping::Result<Any|*>[1] {
  let state = CompilationState($debug);
  // TODO: safe cast
  let connection = $runtime.connections->at(0);

  let result = $query
    ->intoPExpr()
    ->andThen({node: PExpr[1] | 
      //$debug->debug(| 'PURE Expression plan:');
      //$debug->debug(| $node->meta::rel::compile::ir::utils::display());
      $node->compile({_a: Any[1] | error('Unexpected error during compilation.'); }, $state);
    })
    ->andThen({state: CompilationState[1] | 
      $debug->debug(| 'Column names:');
      $debug->debug(| $state.cols.names);
      $state.current
        ->okOr(| 'No current expression.')
        ->andThen({expr: Expr[1] | 
          let type = $query.genericType.rawType;

          // We distinguish three cases.
          // 1. The type of the query may be a class belonging to our mapping.
          // 2. The type of the query may be `TabularDataSet`, in which case we 
          //    interpret the query results as a table.
          // 3. The type may be a primitive type.
          $type->match([
            {class: Class<Any>[1] |
              switch([
                // Handles case 2.
                case($class == TabularDataSet, {| 
                  // For each case, we specify a postprocessing function which is applied
                  // to the result response returned by RAI. 
                  let postProcessor = {result: RAIResult[1] |
                    let tds = ^TabularDataSet();
                    $result.output
                      ->map({output: Output[1] |
                        let numRows = $output.columns->at(0).values->size();
                        let columns = 
                          range($output.columns->size())
                            ->map({i |
                              ^TDSColumn(name=$state.cols.names->maybeAt($i)->orElse('unknown'), offset=$i);
                            });

                        let rows = range($numRows)
                          ->map({row |
                            let values = 
                              range($output.columns->size())
                                ->map({col |
                                  $output.columns->at($col).values->at($row);
                                });
                            ^TDSRow(parent=$tds, values=$values);
                          });

                        ^$tds(rows=$rows, columns=$columns)->ok();
                      })
                      ->first()
                      ->orElse($tds->ok());
                  };

                  // Return the new state and the postprocessing function.
                  let outputBody = 
                    $state.cols.names
                      ->map({col: String[1] | 
                        $expr
                          ->appl([label($col), var('i')])
                      });

                  let output = 
                    def(
                      rel('output'),
                      if ($outputBody->isEmpty(), | reltrue(), {|
                        $outputBody
                          ->toOneMany()
                          ->product()
                          ->from(var('i'))
                      })
                    );

                  pair(
                    ^$state(
                      program=$state.program->with($output)
                    ), 
                    $postProcessor
                  )
                  ->ok();
                })
              ], {|
                // Handles case 1.
                $mapping
                  ->meta::pure::mapping::_classMappingByClass($class)
                  ->okOr(| format('No class mapping found for `%s`', $class.name))
                  ->tryCastm(@RelSetImplementation)
                  ->them({sets: RelSetImplementation[*] | $sets->first()->toOne(); })
                  ->andThen({set: RelSetImplementation[1] |
                    $set
                      ->propertyOutputs()
                      ->them({rules: Pair<Label,Rule>[*] | 
                        let newState = ^$state(
                          program=$state
                            .program
                            ->with([
                              rel('output')
                                ->appl(label('query'))
                                ->headAtom(var('x'))
                                ->def($expr->atom(var('x')))
                            ])
                            ->with($rules.second)
                        );

                        let postProcessor = {result: RAIResult[1] |
                          $result->buildClasses(
                            $rules.first.identifier,
                            $set,
                            $mapping,
                            $runtime,
                            $exeCtx, 
                            $extensions, 
                            $debug
                          );
                        };

                        pair($newState, $postProcessor);
                      });
                  });
              });
            },
            // Handles case 3.
            {p: PrimitiveType[1] |
              let postProcessor = {result: RAIResult[1] |
                $result.output
                  ->map({output: Output[1] |
                    if ($output.columns->size() == 1, 
                      | $output.columns->at(0)->ok(), 
                      | ^Column(values=[true])->ok() // Handle the case of `true`
                    )
                    ->then({column: Column[1] |
                      $column.values;
                    });
                  })
                  ->first()
                  ->orElse([]->okm());
              };

              pair(
                ^$state(program=
                  $state
                    .program
                    ->with(rel('output')->def($expr))
                ), 
                $postProcessor
              )
              ->ok();
            }
          ]);
        });
    });


  if ($result->isOk(), {|
    let unwrapped = $result->unwrap();
    let compiled = $unwrapped.first.program->render();

    let response = $connection
      ->doRAIExecute($compiled)
      ->maybeFail();

    let output = $unwrapped
      .second
      ->eval($response)
      ->unwrapm();

    ^meta::pure::mapping::Result<Any|*>(
      values=[$output], 
      activities=[^QueryActivity(relSource=$compiled, executionTimeInMS=0)]
    );
  }, {|
    // Fail with error message
    $result->unwrap();
    ^meta::pure::mapping::Result<Any|*>();
  });
}

function <<access.private>> meta::rel::mapping::doRAIExecute(connection: meta::pure::runtime::Connection[1], rel: String[1]): RAIResult[1] {
  println(format('Executing program:\n-------------------\n%s', $rel));
  let result = 
    measure(| $connection->RAIExecute2($rel));
  
  println(format('Executed in %d milliseconds.', $result.first));
  println('');

  $result.second;
}

function <<access.private>> meta::rel::mapping::maybeFail(result: RAIResult[1]): RAIResult[1] {
  if ($result.problems->size() > 0, 
    {| 
      $result
        .problems
        ->map(p | $p->toString())
        ->joinStrings()
        ->fail();
      $result;
    },
    | $result
  );
}

/**
  * Helper function which generates output rules for the property mappings
  * belonging to `set`. Output rules take the format
  * 
  * ```rel
  * def output[:property] = Class:property[x] for x in output[:query]
  * ```
  * 
  * Here, `Class:property` is the property expression associated to the property
  * named `property`. This function assumes that query results are stored in 
  * `output[:query]`
  */
function <<access.private>> meta::rel::mapping::propertyOutputs(
  set: RelSetImplementation[1]
): Result<Pair<Label, Rule>|*>[1] {
  $set.propertyMappings
    ->tryCastm(@RelPropertyMapping)
    ->them({properties: RelPropertyMapping[*] | 
      let primitiveProperties = 
        $properties
          ->filter(p: RelPropertyMapping[1] | $p.property->isPrimitiveValueProperty());
      
      let exprs = zip(
        $primitiveProperties
          .property
          .name
          ->map(n | label($n)), 
        $primitiveProperties.target
      );
        
      $exprs
        ->map({pair |
          $pair.first
            ->pair(
              rel('output')
                ->appl($pair.first)
                ->def(
                  $pair.second
                    ->appl(var('x'))
                    ->for(var('x')
                      ->where(
                        rel('output')
                          ->appl(label('query'))
                          ->atom(var('x'))
                      )
                    )
                )
            )
        });
    });
}

function <<access.private>> meta::rel::mapping::buildClasses(
  result: RAIResult[1],
  keys: String[*],
  set: RelSetImplementation[1],
  mapping: meta::pure::mapping::Mapping[1],
  runtime: meta::pure::runtime::Runtime[1],
  exeCtx: meta::pure::runtime::ExecutionContext[1], 
  extensions: meta::pure::extension::Extension[*], 
  debug: DebugContext[1]
): Result<Any|*>[1] {
  println('Indexing results...');
  let r = 
    measure(| $result->toIndexed());
  
  println(format('Executed in %d milliseconds.', $r.first));
  println('');

  let indexed = $r.second;

  $indexed
    ->values(':query')
    ->map({word |
      let id = $word.values->at(1);
      let keyValues = $keys
        ->map({key |
          let values = 
            $indexed->values(
              format(':%s', $key)
                ->concatenate($id)
            )
            ->map(v | $v.values->last());

          ^KeyValue(key=$key, value=$values);
        });

      let keyInformation = ^KeyInformation(
        sourceConnection=$runtime.connections->at(0),
        pk=$id,
        static=^meta::pure::mapping::StaticMappingInstanceData(
            runtime=$runtime,
            mapping=$mapping,
            systemMapping=contract(),
            setImplementation=$set,
            exeCtx=$exeCtx,
            debug=$debug,
            extensions=$extensions
          )
      );

      $set.class->dynamicNew(
        $keyValues,
        meta::pure::mapping::xStore::crossGetterOverrideToOne_Any_1__Property_1__Any_$0_1$_,
        meta::pure::mapping::xStore::crossGetterOverrideToMany_Any_1__Property_1__Any_MANY_,
        $keyInformation,
        $exeCtx->meta::pure::runtime::getConstraintsManager()
      );
    })
    ->okm();
}

function meta::rel::mapping::getterOverrideMapped(o:Any[1], propertyMapping: meta::pure::mapping::PropertyMapping[1]):Any[*] {
  let keyInformation = $o->getHiddenPayload()->cast(@KeyInformation);
  let relProperty = $propertyMapping->cast(@RelPropertyMapping);
  let mapping = $keyInformation.static.mapping;
  let exeCtx = $keyInformation.static.exeCtx;
  let debug = $keyInformation.static.debug;
  let extensions = $keyInformation.static.extensions;
  let runtime = $keyInformation.static.runtime;

  let targetSet = $mapping->meta::pure::mapping::classMappingById($relProperty.targetSetImplementationId)->toOne()->cast(@RelSetImplementation);
  let connection = $keyInformation.sourceConnection->cast(@meta::rel::runtime::RAIConnection);

  let body = $relProperty.target
    ->appl(
      rel('uint128_hash_value_convert')
        ->appl(
          fragment(
            '0x' + 
              $keyInformation.pk
                ->toOne()
                ->cast(@String)
                ->parseDecimal()
                ->decToBinary()
                ->binaryToHex()
          )
        )
    );
  
  let rules = $targetSet
    ->propertyOutputs()
    ->unwrapm();

  let program = 
    def(
      rel('output')->appl(label('query')),
      $body
    )
    ->program()
    ->with($rules.second);
  
  let response = 
    $connection
      ->doRAIExecute($program->render())
      ->maybeFail();

  $response
    ->buildClasses(
      $rules.first.identifier, 
      $targetSet, 
      $mapping, 
      $runtime, 
      $exeCtx, 
      $extensions, 
      $debug
    )
    ->unwrapm();
}

function meta::rel::mapping::supports(f: FunctionExpression[1]): Boolean[1] {
  true;
}

function meta::rel::mapping::supportsStream(f: FunctionExpression[1]): Boolean[1] {
//
// FIXME: Commented out to fix the build.
//  [
//      meta::pure::functions::collection::in_Any_1__Any_MANY__Boolean_1_,
//      meta::pure::functions::collection::in_Any_$0_1$__Any_MANY__Boolean_1_
//  ]->contains($f.func);
    true;
}

function meta::rel::mapping::planExecution(
  sq: meta::pure::mapping::StoreQuery[1], 
  ext: RoutedValueSpecification[0..1], 
  mapping: meta::pure::mapping::Mapping[0..1], 
  runtime: meta::pure::runtime::Runtime[0..1], 
  exeCtx: meta::pure::runtime::ExecutionContext[1], 
  extensions: meta::pure::router::extension::RouterExtension[*], 
  debug:DebugContext[1]
): ExecutionNode[1] {
  fail('Not implemented');
  
  ^ExecutionNode(resultType=^ResultType(type=^Type()));
}